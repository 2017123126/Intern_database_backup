# Banksalad Product Language를 소개합니다 (feat. Figma)

Tags: PM
관련 링크: https://blog.banksalad.com/tech/banksalad-product-language-ios/
상태: Done
작성 일자: 2022년 11월 3일 오전 11:17

[BPLExample.mov](Banksalad%20Product%20Language%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%A9%E1%84%80%E1%85%A2%E1%84%92%E1%85%A1%E1%86%B8%E1%84%82%E1%85%B5%E1%84%83%E1%85%A1%20(feat%20Fi%201a29ab42b98947089f14562ae9139d4f/BPLExample.mov)

## Product Language가 뭔가요?

Product Language는 디자인 시스템의 확장판이라고 보시면 이해가 수월할 것 같습니다. 즉 일반적인 디자인 시스템이 디자인에 한정된 내용을 다루는 경향이 있다고 한다면, Product Language는 제품을 만드는 구성원 모두가 공유하고 사용하며 만들어가는 언어라고 할 수 있어요. 

(현식: 내가 볼 땐 그냥 피그마 asset들을 정해놓고 각각의 asset에 프론트엔드 코드들을 대응하고 이름을 붙여놓은 것인 듯?)

## BPL(Banksalad Product Language)이란?

직군이나 조직별로 UI를 추상화하는 단위나 방법이 다르기 때문에 많은 문제가 생겨납니다. 디자이너 입장에서는 특정 아트보드에만 영향이 가는 심볼을 수정한 것인데 iOS입장에서는 특정 네비게이션 플로우 전체에 영향이 가는 수정이 되고 Android는 앱 전체에 영향이 가는 수정이 되어버리는 상황이 얼마든지 일어날 수 있습니다. 또 추상화의 단위와 방법이 다르니 자연스레 각 컴포넌트를 부르는 이름들도 달라질 수밖에 없습니다.

이 문제에 대한 해결책은 제품을 만드는 모든 구성원이 UI를 추상화하는 규칙 및 단위를 공유하는 것이죠. 그리고 그 공유의 방식과 내용을 뱅크샐러드에서는 BPL이라고 부릅니다.

![dialog2.png](Banksalad%20Product%20Language%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%A9%E1%84%80%E1%85%A2%E1%84%92%E1%85%A1%E1%86%B8%E1%84%82%E1%85%B5%E1%84%83%E1%85%A1%20(feat%20Fi%201a29ab42b98947089f14562ae9139d4f/dialog2.png)

![dialog1.png](Banksalad%20Product%20Language%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%A9%E1%84%80%E1%85%A2%E1%84%92%E1%85%A1%E1%86%B8%E1%84%82%E1%85%B5%E1%84%83%E1%85%A1%20(feat%20Fi%201a29ab42b98947089f14562ae9139d4f/dialog1.png)

## BPL을 만들기까지

최초에 의사소통이 잘 되지 않는 기간이 있을 것이란 것을 염두에 두고, 더 원활히 의사소통 할 수 있는 다양한 방법을 고민해 보았습니다. 그런 여러 노력들 중 가장 유효했던 두 가지 노력에 대해 이야기해 보겠습니다.

### 1. 뭘 만들어야 할지 모르겠을 때는, 일단 만들어봅시다.

> Communication cost is most expensive.
Code and Show first, argue after that.
> 

뱅크샐러드에서는 뭔가 부족하고 조잡하더라도, 일단은 어떻게든 각자의 생각을 최대한 코드로 구현해 돌아가는 제품을 먼저 만드는 문화를 가지고 있습니다. 

“확실하게 의사소통”하는 일은 매우 어렵고 심지어는 가능할지조차 불확실한 경우가 많습니다. 이런 불확실성을 줄일 수 있는 가장 빠르고 강력한 방법 중 하나가, 내 코드의 대부분이 버려질 것을 각오하고서라도 어떻게든 돌아가는 제품을 만드는 것입니다. 

예컨대 Container와 Child의 관계는 세 플랫폼이 거의 비슷한 개념을 가지고 있었지만, 실제로 각 Container가 어떤 속성들을 들고 있는지는 조금씩 달랐습니다. 이렇게 코드를 비교하고 보니 “결국 우리가 합의해야 하는 것은 이 Container가 어떤 메소드와 속성을 가져야 하는지를 확립하는 것이구나!”라는 것을 알 수 있었고, 회의의 목적이 분명해지고 보니 회의는 허무할 정도로 빠른 속도로 끝이 났습니다. 

### 2. 서로의 도구를 사용해 봅시다

많은 경우 디자이너와 개발자는 같은 시점에 배포되는 같은 문제를 해결하는 제품, 즉 같은 Concern에 대해 얘기 해야만 하는 경우가 많습니다. 

Figma라는 도구에서는 이 두 당사자간의 의사소통의 벽을 넘나드는 일이 굉장히 쉬웠습니다. Editor모드에서는 디자이너가 사용하는 메뉴와 툴들을 모두 쓸 수 있게 되며, 오직 디자이너가 수정한 숫자들만 보거나 만질 수 있습니다. 이 모드에서는 Zeplin같은 툴이 자동으로 생성해주는, 즉 디자이너가 직접 만들지 않은 가이드들을 만날 수 없기 때문에 디자이너가 어떤 의도로 이 컴포넌트를 만들었는지 훨씬 명확히 알 수 있습니다. 

## BPL의 구조

### 1. 최대한 Flat하게

우리는 각 컴포넌트들을 만들 때 상속이나 추상화보다는 “복사/붙여넣기” 신공을 훨씬 많이 썼습니다. 설령 지금은 그 둘이 굉장히 비슷해 보인다고 하더라도, “Figma에서 서로 의존성이 없는 독립적 컴포넌트라면 코드레벨에서도 서로 의존성이 없는 독립적 컴포넌트여야” 했기 때문입니다.

### 2. SwiftUI 처럼

Figma에서 BPL의 컴포넌트를 활용해 어떤 화면을 만들었다면 Figma의 왼쪽 구역에는 이 컴포넌트들간의 위계가 표현됩니다. 바로 이 위계가 코드레벨에서도 보여야 한다는 것이죠. 이런 위계를 보여주기 위해서는 SwiftUI의 구조를 많이 참고했습니다.